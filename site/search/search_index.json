{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"reference/chalifour/db/","title":"chalifour.db","text":""},{"location":"reference/chalifour/db/containers/","title":"chalifour.db.containers","text":"<p>Dependency injection containers for the Chalifour database module.</p> <p>This module provides dependency injection containers that manage the lifecycle and dependencies of database components, particularly the model repository registry. It leverages the dependency_injector library to implement IoC (Inversion of Control) patterns for better testability and modularity.</p>"},{"location":"reference/chalifour/db/containers/#chalifour.db.containers.ModelRegistryContainer","title":"<code>ModelRegistryContainer</code>","text":"<p>               Bases: <code>DeclarativeContainer</code></p> <p>Dependency injection container for the model registry system.</p> <p>This container manages the lifecycle of the ModelRepositoryRegistry and its dependencies. It provides configuration-based repository class loading, factory creation, and handles the registration of models that were deferred during application startup.</p> <p>Attributes:</p> Name Type Description <code>config</code> <p>Configuration provider for container settings</p> <code>wiring_config</code> <p>Configuration for dependency injection wiring</p> <code>model_repository_class</code> <p>Provider that dynamically loads the repository class</p> <code>model_repository_factory</code> <p>Factory provider for creating repository instances</p> <code>registry</code> <p>Singleton provider for the ModelRepositoryRegistry</p> <code>register_models</code> <p>Provider that triggers registration of deferred models</p> Source code in <code>src/chalifour/db/containers.py</code> <pre><code>class ModelRegistryContainer(containers.DeclarativeContainer):\n    \"\"\"\n    Dependency injection container for the model registry system.\n\n    This container manages the lifecycle of the ModelRepositoryRegistry and its dependencies.\n    It provides configuration-based repository class loading, factory creation, and\n    handles the registration of models that were deferred during application startup.\n\n    Attributes:\n        config: Configuration provider for container settings\n        wiring_config: Configuration for dependency injection wiring\n        model_repository_class: Provider that dynamically loads the repository class\n        model_repository_factory: Factory provider for creating repository instances\n        registry: Singleton provider for the ModelRepositoryRegistry\n        register_models: Provider that triggers registration of deferred models\n    \"\"\"\n\n    config = providers.Configuration()\n    wiring_config = containers.WiringConfiguration(\n        packages=[\n            \"chalifour.db.registry\",\n        ],\n    )\n\n    model_repository_class = providers.Callable(\n        get_repository_class_from_path,\n        class_path=config.class_path,\n    )\n\n    model_repository_factory = providers.Factory(model_repository_class)\n\n    registry = providers.Singleton(\n        ModelRepositoryRegistry,\n        model_repository_factory=model_repository_factory,\n    )\n\n    register_models = providers.Callable(_register_deferred_models, registry=registry)\n</code></pre>"},{"location":"reference/chalifour/db/models/","title":"chalifour.db.models","text":""},{"location":"reference/chalifour/db/models/base/","title":"chalifour.db.models.base","text":""},{"location":"reference/chalifour/db/registry/","title":"chalifour.db.registry","text":""},{"location":"reference/chalifour/db/registry/#chalifour.db.registry.ModelRepositoryRegistry","title":"<code>ModelRepositoryRegistry</code>","text":"<p>Registry for managing model repositories.</p> <p>This class provides a centralized registry for model repositories, allowing different model types to be associated with their respective repository instances. It supports automatic repository creation through a factory pattern and provides lookup functionality to retrieve repositories by model type.</p> <p>The registry is useful for dependency injection scenarios where repositories need to be accessed throughout the application without creating new instances.</p> Source code in <code>src/chalifour/db/registry/_model_repository_registry.py</code> <pre><code>class ModelRepositoryRegistry:\n    \"\"\"\n    Registry for managing model repositories.\n\n    This class provides a centralized registry for model repositories, allowing\n    different model types to be associated with their respective repository instances.\n    It supports automatic repository creation through a factory pattern and provides\n    lookup functionality to retrieve repositories by model type.\n\n    The registry is useful for dependency injection scenarios where repositories\n    need to be accessed throughout the application without creating new instances.\n    \"\"\"\n\n    _repositories: Dict[\n        Type[Any], ModelRepository[Any]\n    ] = {}  # Use Any for TypeVar within registry itself\n\n    _model_repository_factory: Callable[[Any], ModelRepository[Any]]\n\n    @inject\n    def __init__(\n        self,\n        model_repository_factory: Callable[[Any], ModelRepository[Any]],\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ModelRepositoryRegistry.\n\n        Args:\n            model_repository_factory: A factory function that creates repository\n                instances for a given model type. This function should accept a\n                model type and return a ModelRepository instance for that type.\n        \"\"\"\n        self._model_repository_factory = model_repository_factory\n\n    def register_model(self, model_type: Type[T]):\n        \"\"\"\n        Register a model type by creating and registering a repository for it.\n\n        This method uses the factory function provided during initialization\n        to create a repository instance for the given model type.\n\n        Args:\n            model_type: The model class to register.\n        \"\"\"\n        self.register_repository(\n            model_type,\n            self._model_repository_factory(model_type),\n        )\n\n    def register_repository(\n        self,\n        model_type: Type[T],\n        repository_instance: ModelRepository[T],\n    ):\n        \"\"\"\n        Register a repository instance for a specific model type.\n\n        This method allows manual registration of custom repository instances\n        for specific model types.\n\n        Args:\n            model_type: The model class to register.\n            repository_instance: The repository instance to associate with the model type.\n        \"\"\"\n        self._repositories[model_type] = repository_instance\n        print(f\"Registered repository for model '{model_type.__name__}'\")\n\n    def get_repository(self, model_type: Type[T]) -&gt; ModelRepository[T]:\n        \"\"\"\n        Retrieve the repository instance for a specific model type.\n\n        Args:\n            model_type: The model class to get the repository for.\n\n        Returns:\n            The repository instance associated with the model type.\n\n        Raises:\n            Exception: If no repository is registered for the given model type.\n        \"\"\"\n        if model_type in self._repositories:\n            return self._repositories[model_type]\n        print(f\"No repository found for model '{model_type.__name__}'\")\n        raise KeyError(\n            f\"No repository registered for model type: {model_type.__name__}\"\n        )\n</code></pre>"},{"location":"reference/chalifour/db/registry/#chalifour.db.registry.ModelRepositoryRegistry.__init__","title":"<code>__init__(model_repository_factory)</code>","text":"<p>Initialize the ModelRepositoryRegistry.</p> <p>Parameters:</p> Name Type Description Default <code>model_repository_factory</code> <code>Callable[[Any], ModelRepository[Any]]</code> <p>A factory function that creates repository instances for a given model type. This function should accept a model type and return a ModelRepository instance for that type.</p> required Source code in <code>src/chalifour/db/registry/_model_repository_registry.py</code> <pre><code>@inject\ndef __init__(\n    self,\n    model_repository_factory: Callable[[Any], ModelRepository[Any]],\n) -&gt; None:\n    \"\"\"\n    Initialize the ModelRepositoryRegistry.\n\n    Args:\n        model_repository_factory: A factory function that creates repository\n            instances for a given model type. This function should accept a\n            model type and return a ModelRepository instance for that type.\n    \"\"\"\n    self._model_repository_factory = model_repository_factory\n</code></pre>"},{"location":"reference/chalifour/db/registry/#chalifour.db.registry.ModelRepositoryRegistry.get_repository","title":"<code>get_repository(model_type)</code>","text":"<p>Retrieve the repository instance for a specific model type.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[T]</code> <p>The model class to get the repository for.</p> required <p>Returns:</p> Type Description <code>ModelRepository[T]</code> <p>The repository instance associated with the model type.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If no repository is registered for the given model type.</p> Source code in <code>src/chalifour/db/registry/_model_repository_registry.py</code> <pre><code>def get_repository(self, model_type: Type[T]) -&gt; ModelRepository[T]:\n    \"\"\"\n    Retrieve the repository instance for a specific model type.\n\n    Args:\n        model_type: The model class to get the repository for.\n\n    Returns:\n        The repository instance associated with the model type.\n\n    Raises:\n        Exception: If no repository is registered for the given model type.\n    \"\"\"\n    if model_type in self._repositories:\n        return self._repositories[model_type]\n    print(f\"No repository found for model '{model_type.__name__}'\")\n    raise KeyError(\n        f\"No repository registered for model type: {model_type.__name__}\"\n    )\n</code></pre>"},{"location":"reference/chalifour/db/registry/#chalifour.db.registry.ModelRepositoryRegistry.register_model","title":"<code>register_model(model_type)</code>","text":"<p>Register a model type by creating and registering a repository for it.</p> <p>This method uses the factory function provided during initialization to create a repository instance for the given model type.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[T]</code> <p>The model class to register.</p> required Source code in <code>src/chalifour/db/registry/_model_repository_registry.py</code> <pre><code>def register_model(self, model_type: Type[T]):\n    \"\"\"\n    Register a model type by creating and registering a repository for it.\n\n    This method uses the factory function provided during initialization\n    to create a repository instance for the given model type.\n\n    Args:\n        model_type: The model class to register.\n    \"\"\"\n    self.register_repository(\n        model_type,\n        self._model_repository_factory(model_type),\n    )\n</code></pre>"},{"location":"reference/chalifour/db/registry/#chalifour.db.registry.ModelRepositoryRegistry.register_repository","title":"<code>register_repository(model_type, repository_instance)</code>","text":"<p>Register a repository instance for a specific model type.</p> <p>This method allows manual registration of custom repository instances for specific model types.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[T]</code> <p>The model class to register.</p> required <code>repository_instance</code> <code>ModelRepository[T]</code> <p>The repository instance to associate with the model type.</p> required Source code in <code>src/chalifour/db/registry/_model_repository_registry.py</code> <pre><code>def register_repository(\n    self,\n    model_type: Type[T],\n    repository_instance: ModelRepository[T],\n):\n    \"\"\"\n    Register a repository instance for a specific model type.\n\n    This method allows manual registration of custom repository instances\n    for specific model types.\n\n    Args:\n        model_type: The model class to register.\n        repository_instance: The repository instance to associate with the model type.\n    \"\"\"\n    self._repositories[model_type] = repository_instance\n    print(f\"Registered repository for model '{model_type.__name__}'\")\n</code></pre>"},{"location":"reference/chalifour/db/registry/#chalifour.db.registry.registered_model","title":"<code>registered_model(cls)</code>","text":"<p>Decorator to automatically register a model's repository with the global RepositoryRegistry.</p> Source code in <code>src/chalifour/db/registry/_decorators.py</code> <pre><code>def registered_model(cls: Type[Any]) -&gt; Type[Any]:\n    \"\"\"\n    Decorator to automatically register a model's repository with the global RepositoryRegistry.\n    \"\"\"\n\n    _deferred_registered_models.append(cls)\n\n    return cls\n</code></pre>"},{"location":"reference/chalifour/db/repository/","title":"chalifour.db.repository","text":""},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.ModelRepository","title":"<code>ModelRepository</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for a generic model repository. Defines common CRUD operations for any model type.</p> <p>Attributes:</p> Name Type Description <code>model_class</code> <p>Wrapper class for the model object</p> Source code in <code>src/chalifour/db/repository/_model_repository.py</code> <pre><code>class ModelRepository(Generic[T], abc.ABC):\n    \"\"\"\n    Abstract base class for a generic model repository.\n    Defines common CRUD operations for any model type.\n\n    Attributes:\n        model_class: Wrapper class for the model object\n    \"\"\"\n\n    def __init__(self, model_class: Type[T]) -&gt; None:\n        self.model_class = model_class\n\n    @abc.abstractmethod\n    def create(self, model_data: Dict[str, Any]) -&gt; Optional[T]:\n        \"\"\"\n        Creates a new model instance in the database.\n        :param model_data: A dictionary containing the data for the new model.\n        :return: The created model instance or None if creation fails (e.g., due to duplicate key).\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_by_id(self, model_id: Any) -&gt; Optional[T]:\n        \"\"\"\n        Retrieves a model instance by its ID.\n        The type of model_id will depend on the database (e.g., int for SQL, ObjectId for MongoDB).\n        :param model_id: The unique identifier of the model.\n        :return: The model instance or None if not found.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def find_one(self, query: Dict[str, Any]) -&gt; Optional[T]:\n        \"\"\"\n        Finds a single model instance based on a query.\n        The query format will vary by database.\n        :param query: A dictionary representing the search criteria.\n        :return: A single model instance or None if not found.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def find_all(\n        self,\n        query: Optional[Dict[str, Any]] = None,\n        limit: Optional[int] = None,\n        skip: Optional[int] = None,\n    ) -&gt; List[T]:\n        \"\"\"\n        Finds all model instances matching a query, with optional pagination.\n        :param query: Optional dictionary representing the search criteria. If None, retrieves all.\n        :param limit: Maximum number of results to return.\n        :param skip: Number of results to skip (for pagination).\n        :return: A list of model instances.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def update(self, model_id: Any, update_data: Dict[str, Any]) -&gt; Optional[T]:\n        \"\"\"\n        Updates an existing model instance.\n        :param model_id: The ID of the model to update.\n        :param update_data: A dictionary containing the fields to update and their new values.\n        :return: The updated model instance or None if not found/updated.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def delete(self, model_id: Any) -&gt; bool:\n        \"\"\"\n        Deletes a model instance by its ID.\n        :param model_id: The ID of the model to delete.\n        :return: True if the model was deleted, False otherwise.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def count(self, query: Optional[Dict[str, Any]] = None) -&gt; int:\n        \"\"\"\n        Counts the number of model instances matching a query.\n        :param query: Optional dictionary representing the search criteria.\n        :return: The number of matching instances.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.ModelRepository.count","title":"<code>count(query=None)</code>  <code>abstractmethod</code>","text":"<p>Counts the number of model instances matching a query. :param query: Optional dictionary representing the search criteria. :return: The number of matching instances.</p> Source code in <code>src/chalifour/db/repository/_model_repository.py</code> <pre><code>@abc.abstractmethod\ndef count(self, query: Optional[Dict[str, Any]] = None) -&gt; int:\n    \"\"\"\n    Counts the number of model instances matching a query.\n    :param query: Optional dictionary representing the search criteria.\n    :return: The number of matching instances.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.ModelRepository.create","title":"<code>create(model_data)</code>  <code>abstractmethod</code>","text":"<p>Creates a new model instance in the database. :param model_data: A dictionary containing the data for the new model. :return: The created model instance or None if creation fails (e.g., due to duplicate key).</p> Source code in <code>src/chalifour/db/repository/_model_repository.py</code> <pre><code>@abc.abstractmethod\ndef create(self, model_data: Dict[str, Any]) -&gt; Optional[T]:\n    \"\"\"\n    Creates a new model instance in the database.\n    :param model_data: A dictionary containing the data for the new model.\n    :return: The created model instance or None if creation fails (e.g., due to duplicate key).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.ModelRepository.delete","title":"<code>delete(model_id)</code>  <code>abstractmethod</code>","text":"<p>Deletes a model instance by its ID. :param model_id: The ID of the model to delete. :return: True if the model was deleted, False otherwise.</p> Source code in <code>src/chalifour/db/repository/_model_repository.py</code> <pre><code>@abc.abstractmethod\ndef delete(self, model_id: Any) -&gt; bool:\n    \"\"\"\n    Deletes a model instance by its ID.\n    :param model_id: The ID of the model to delete.\n    :return: True if the model was deleted, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.ModelRepository.find_all","title":"<code>find_all(query=None, limit=None, skip=None)</code>  <code>abstractmethod</code>","text":"<p>Finds all model instances matching a query, with optional pagination. :param query: Optional dictionary representing the search criteria. If None, retrieves all. :param limit: Maximum number of results to return. :param skip: Number of results to skip (for pagination). :return: A list of model instances.</p> Source code in <code>src/chalifour/db/repository/_model_repository.py</code> <pre><code>@abc.abstractmethod\ndef find_all(\n    self,\n    query: Optional[Dict[str, Any]] = None,\n    limit: Optional[int] = None,\n    skip: Optional[int] = None,\n) -&gt; List[T]:\n    \"\"\"\n    Finds all model instances matching a query, with optional pagination.\n    :param query: Optional dictionary representing the search criteria. If None, retrieves all.\n    :param limit: Maximum number of results to return.\n    :param skip: Number of results to skip (for pagination).\n    :return: A list of model instances.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.ModelRepository.find_one","title":"<code>find_one(query)</code>  <code>abstractmethod</code>","text":"<p>Finds a single model instance based on a query. The query format will vary by database. :param query: A dictionary representing the search criteria. :return: A single model instance or None if not found.</p> Source code in <code>src/chalifour/db/repository/_model_repository.py</code> <pre><code>@abc.abstractmethod\ndef find_one(self, query: Dict[str, Any]) -&gt; Optional[T]:\n    \"\"\"\n    Finds a single model instance based on a query.\n    The query format will vary by database.\n    :param query: A dictionary representing the search criteria.\n    :return: A single model instance or None if not found.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.ModelRepository.get_by_id","title":"<code>get_by_id(model_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieves a model instance by its ID. The type of model_id will depend on the database (e.g., int for SQL, ObjectId for MongoDB). :param model_id: The unique identifier of the model. :return: The model instance or None if not found.</p> Source code in <code>src/chalifour/db/repository/_model_repository.py</code> <pre><code>@abc.abstractmethod\ndef get_by_id(self, model_id: Any) -&gt; Optional[T]:\n    \"\"\"\n    Retrieves a model instance by its ID.\n    The type of model_id will depend on the database (e.g., int for SQL, ObjectId for MongoDB).\n    :param model_id: The unique identifier of the model.\n    :return: The model instance or None if not found.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.ModelRepository.update","title":"<code>update(model_id, update_data)</code>  <code>abstractmethod</code>","text":"<p>Updates an existing model instance. :param model_id: The ID of the model to update. :param update_data: A dictionary containing the fields to update and their new values. :return: The updated model instance or None if not found/updated.</p> Source code in <code>src/chalifour/db/repository/_model_repository.py</code> <pre><code>@abc.abstractmethod\ndef update(self, model_id: Any, update_data: Dict[str, Any]) -&gt; Optional[T]:\n    \"\"\"\n    Updates an existing model instance.\n    :param model_id: The ID of the model to update.\n    :param update_data: A dictionary containing the fields to update and their new values.\n    :return: The updated model instance or None if not found/updated.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.MongoDBModelRepository","title":"<code>MongoDBModelRepository</code>","text":"<p>               Bases: <code>ModelRepository[T]</code></p> <p>MongoDB implementation of the ModelRepository interface.</p> <p>This class provides CRUD operations for MongoDB collections, with support for wrapping database documents in model classes for easier access.</p> <p>Attributes:</p> Name Type Description <code>client</code> <p>The MongoDB client connection</p> <code>db</code> <p>The MongoDB database instance</p> <code>collection</code> <p>The MongoDB collection being managed</p> <code>model_class</code> <p>Class used to wrap raw MongoDB documents</p> Source code in <code>src/chalifour/db/repository/_mongo_db_model_repository.py</code> <pre><code>class MongoDBModelRepository(ModelRepository[T]):\n    \"\"\"\n    MongoDB implementation of the ModelRepository interface.\n\n    This class provides CRUD operations for MongoDB collections, with support\n    for wrapping database documents in model classes for easier access.\n\n    Attributes:\n        client: The MongoDB client connection\n        db: The MongoDB database instance\n        collection: The MongoDB collection being managed\n        model_class: Class used to wrap raw MongoDB documents\n    \"\"\"\n\n    def __init__(self, model_class: Type[T]):\n        \"\"\"\n        Initialize a MongoDB model manager.\n\n        Args:\n            model_class: Class to wrap returned documents (provides object-oriented access)\n        \"\"\"\n        super().__init__(model_class)\n\n        connection_string = os.environ.get(\"MONGODB_CONNECTION_STRING\", \"\")\n        db_name = os.environ.get(\"MONGODB_DATABASE_NAME\", \"database\")\n        collection_name = model_class.__name__\n\n        self.client = MongoClient(connection_string)\n        self.db = self.client[db_name]\n        self.collection = self.db[collection_name]\n        # Ensure unique email index for consistency if email is a common field\n        self.collection.create_index(\"email\", unique=True, background=True)\n\n    def _wrap_result(self, data: Optional[Dict[str, Any]]) -&gt; Optional[T]:\n        \"\"\"\n        Wrap a MongoDB document in the model wrapper class.\n\n        Args:\n            data: Raw MongoDB document dictionary\n\n        Returns:\n            An instance of the model wrapper class or None if data is None\n        \"\"\"\n        if data:\n            return self.model_class(**data)\n        return None\n\n    def create(self, model_data: Dict[str, Any]) -&gt; Optional[T]:\n        \"\"\"\n        Create a new document in the MongoDB collection.\n\n        Args:\n            model_data: Dictionary containing the document data\n\n        Returns:\n            The created model instance or None if creation fails (e.g., due to duplicate key)\n\n        Note:\n            The returned model includes the MongoDB-generated _id field\n        \"\"\"\n        try:\n            result = self.collection.insert_one(model_data)\n            # MongoDB returns _id as ObjectId, ensure it's in the returned dict\n            model_data[\"_id\"] = result.inserted_id\n            return self._wrap_result(model_data)\n        except DuplicateKeyError as e:\n            print(f\"MongoDB create error: {e}\")\n            return None\n\n    def get_by_id(self, model_id: Any) -&gt; Optional[T]:\n        \"\"\"\n        Retrieve a document by its MongoDB _id.\n\n        Args:\n            model_id: The document's _id (can be string or ObjectId)\n\n        Returns:\n            The model instance or None if not found or if the ID format is invalid\n        \"\"\"\n        if not isinstance(model_id, ObjectId):\n            try:\n                model_id = ObjectId(model_id)\n            except Exception:\n                return None  # Invalid ObjectId format\n\n        result = self.collection.find_one({\"_id\": model_id})\n        return self._wrap_result(result)\n\n    def find_one(self, query: Dict[str, Any]) -&gt; Optional[T]:\n        \"\"\"\n        Find a single document matching the query criteria.\n\n        Args:\n            query: MongoDB query dictionary\n\n        Returns:\n            The first matching model instance or None if no matches found\n        \"\"\"\n        result = self.collection.find_one(query)\n        return self._wrap_result(result)\n\n    def find_all(\n        self,\n        query: Optional[Dict[str, Any]] = None,\n        limit: Optional[int] = None,\n        skip: Optional[int] = None,\n    ) -&gt; List[T]:\n        \"\"\"\n        Find all documents matching the query criteria with optional pagination.\n\n        Args:\n            query: MongoDB query dictionary (defaults to empty query which matches all documents)\n            limit: Maximum number of results to return\n            skip: Number of results to skip (for pagination)\n\n        Returns:\n            A list of model instances matching the query\n        \"\"\"\n        query = query if query is not None else {}\n        cursor = self.collection.find(query)\n        if skip is not None:\n            cursor = cursor.skip(skip)\n        if limit is not None:\n            cursor = cursor.limit(limit)\n        results = [self._wrap_result(doc) for doc in cursor]\n        return [r for r in results if r is not None]\n\n    def update(self, model_id: Any, update_data: Dict[str, Any]) -&gt; Optional[T]:\n        \"\"\"\n        Update an existing document by its _id.\n\n        Args:\n            model_id: The document's _id (can be string or ObjectId)\n            update_data: Dictionary containing the fields to update and their new values\n\n        Returns:\n            The updated model instance or None if not found/updated or if the ID format is invalid\n\n        Note:\n            Uses MongoDB's $set operator to update only the specified fields\n        \"\"\"\n        if not isinstance(model_id, ObjectId):\n            try:\n                model_id = ObjectId(model_id)\n            except Exception:\n                return None\n\n        try:\n            result = self.collection.update_one(\n                {\"_id\": model_id}, {\"$set\": update_data}\n            )\n            if result.matched_count &gt; 0:\n                return self.get_by_id(model_id)  # Fetch the updated document\n            return None\n        except DuplicateKeyError as e:\n            print(f\"MongoDB update error: {e}\")\n            return None\n\n    def delete(self, model_id: Any) -&gt; bool:\n        \"\"\"\n        Delete a document by its _id.\n\n        Args:\n            model_id: The document's _id (can be string or ObjectId)\n\n        Returns:\n            True if the document was deleted, False otherwise or if the ID format is invalid\n        \"\"\"\n        if not isinstance(model_id, ObjectId):\n            try:\n                model_id = ObjectId(model_id)\n            except Exception:\n                return False\n\n        result = self.collection.delete_one({\"_id\": model_id})\n        return result.deleted_count &gt; 0\n\n    def count(self, query: Optional[Dict[str, Any]] = None) -&gt; int:\n        \"\"\"\n        Count the number of documents matching a query.\n\n        Args:\n            query: MongoDB query dictionary (defaults to empty query which matches all documents)\n\n        Returns:\n            The number of matching documents\n        \"\"\"\n        query = query if query is not None else {}\n        return self.collection.count_documents(query)\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.MongoDBModelRepository.__init__","title":"<code>__init__(model_class)</code>","text":"<p>Initialize a MongoDB model manager.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>Type[T]</code> <p>Class to wrap returned documents (provides object-oriented access)</p> required Source code in <code>src/chalifour/db/repository/_mongo_db_model_repository.py</code> <pre><code>def __init__(self, model_class: Type[T]):\n    \"\"\"\n    Initialize a MongoDB model manager.\n\n    Args:\n        model_class: Class to wrap returned documents (provides object-oriented access)\n    \"\"\"\n    super().__init__(model_class)\n\n    connection_string = os.environ.get(\"MONGODB_CONNECTION_STRING\", \"\")\n    db_name = os.environ.get(\"MONGODB_DATABASE_NAME\", \"database\")\n    collection_name = model_class.__name__\n\n    self.client = MongoClient(connection_string)\n    self.db = self.client[db_name]\n    self.collection = self.db[collection_name]\n    # Ensure unique email index for consistency if email is a common field\n    self.collection.create_index(\"email\", unique=True, background=True)\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.MongoDBModelRepository.count","title":"<code>count(query=None)</code>","text":"<p>Count the number of documents matching a query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Optional[Dict[str, Any]]</code> <p>MongoDB query dictionary (defaults to empty query which matches all documents)</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of matching documents</p> Source code in <code>src/chalifour/db/repository/_mongo_db_model_repository.py</code> <pre><code>def count(self, query: Optional[Dict[str, Any]] = None) -&gt; int:\n    \"\"\"\n    Count the number of documents matching a query.\n\n    Args:\n        query: MongoDB query dictionary (defaults to empty query which matches all documents)\n\n    Returns:\n        The number of matching documents\n    \"\"\"\n    query = query if query is not None else {}\n    return self.collection.count_documents(query)\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.MongoDBModelRepository.create","title":"<code>create(model_data)</code>","text":"<p>Create a new document in the MongoDB collection.</p> <p>Parameters:</p> Name Type Description Default <code>model_data</code> <code>Dict[str, Any]</code> <p>Dictionary containing the document data</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The created model instance or None if creation fails (e.g., due to duplicate key)</p> Note <p>The returned model includes the MongoDB-generated _id field</p> Source code in <code>src/chalifour/db/repository/_mongo_db_model_repository.py</code> <pre><code>def create(self, model_data: Dict[str, Any]) -&gt; Optional[T]:\n    \"\"\"\n    Create a new document in the MongoDB collection.\n\n    Args:\n        model_data: Dictionary containing the document data\n\n    Returns:\n        The created model instance or None if creation fails (e.g., due to duplicate key)\n\n    Note:\n        The returned model includes the MongoDB-generated _id field\n    \"\"\"\n    try:\n        result = self.collection.insert_one(model_data)\n        # MongoDB returns _id as ObjectId, ensure it's in the returned dict\n        model_data[\"_id\"] = result.inserted_id\n        return self._wrap_result(model_data)\n    except DuplicateKeyError as e:\n        print(f\"MongoDB create error: {e}\")\n        return None\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.MongoDBModelRepository.delete","title":"<code>delete(model_id)</code>","text":"<p>Delete a document by its _id.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>Any</code> <p>The document's _id (can be string or ObjectId)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the document was deleted, False otherwise or if the ID format is invalid</p> Source code in <code>src/chalifour/db/repository/_mongo_db_model_repository.py</code> <pre><code>def delete(self, model_id: Any) -&gt; bool:\n    \"\"\"\n    Delete a document by its _id.\n\n    Args:\n        model_id: The document's _id (can be string or ObjectId)\n\n    Returns:\n        True if the document was deleted, False otherwise or if the ID format is invalid\n    \"\"\"\n    if not isinstance(model_id, ObjectId):\n        try:\n            model_id = ObjectId(model_id)\n        except Exception:\n            return False\n\n    result = self.collection.delete_one({\"_id\": model_id})\n    return result.deleted_count &gt; 0\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.MongoDBModelRepository.find_all","title":"<code>find_all(query=None, limit=None, skip=None)</code>","text":"<p>Find all documents matching the query criteria with optional pagination.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Optional[Dict[str, Any]]</code> <p>MongoDB query dictionary (defaults to empty query which matches all documents)</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of results to return</p> <code>None</code> <code>skip</code> <code>Optional[int]</code> <p>Number of results to skip (for pagination)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[T]</code> <p>A list of model instances matching the query</p> Source code in <code>src/chalifour/db/repository/_mongo_db_model_repository.py</code> <pre><code>def find_all(\n    self,\n    query: Optional[Dict[str, Any]] = None,\n    limit: Optional[int] = None,\n    skip: Optional[int] = None,\n) -&gt; List[T]:\n    \"\"\"\n    Find all documents matching the query criteria with optional pagination.\n\n    Args:\n        query: MongoDB query dictionary (defaults to empty query which matches all documents)\n        limit: Maximum number of results to return\n        skip: Number of results to skip (for pagination)\n\n    Returns:\n        A list of model instances matching the query\n    \"\"\"\n    query = query if query is not None else {}\n    cursor = self.collection.find(query)\n    if skip is not None:\n        cursor = cursor.skip(skip)\n    if limit is not None:\n        cursor = cursor.limit(limit)\n    results = [self._wrap_result(doc) for doc in cursor]\n    return [r for r in results if r is not None]\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.MongoDBModelRepository.find_one","title":"<code>find_one(query)</code>","text":"<p>Find a single document matching the query criteria.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Dict[str, Any]</code> <p>MongoDB query dictionary</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The first matching model instance or None if no matches found</p> Source code in <code>src/chalifour/db/repository/_mongo_db_model_repository.py</code> <pre><code>def find_one(self, query: Dict[str, Any]) -&gt; Optional[T]:\n    \"\"\"\n    Find a single document matching the query criteria.\n\n    Args:\n        query: MongoDB query dictionary\n\n    Returns:\n        The first matching model instance or None if no matches found\n    \"\"\"\n    result = self.collection.find_one(query)\n    return self._wrap_result(result)\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.MongoDBModelRepository.get_by_id","title":"<code>get_by_id(model_id)</code>","text":"<p>Retrieve a document by its MongoDB _id.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>Any</code> <p>The document's _id (can be string or ObjectId)</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The model instance or None if not found or if the ID format is invalid</p> Source code in <code>src/chalifour/db/repository/_mongo_db_model_repository.py</code> <pre><code>def get_by_id(self, model_id: Any) -&gt; Optional[T]:\n    \"\"\"\n    Retrieve a document by its MongoDB _id.\n\n    Args:\n        model_id: The document's _id (can be string or ObjectId)\n\n    Returns:\n        The model instance or None if not found or if the ID format is invalid\n    \"\"\"\n    if not isinstance(model_id, ObjectId):\n        try:\n            model_id = ObjectId(model_id)\n        except Exception:\n            return None  # Invalid ObjectId format\n\n    result = self.collection.find_one({\"_id\": model_id})\n    return self._wrap_result(result)\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.MongoDBModelRepository.update","title":"<code>update(model_id, update_data)</code>","text":"<p>Update an existing document by its _id.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>Any</code> <p>The document's _id (can be string or ObjectId)</p> required <code>update_data</code> <code>Dict[str, Any]</code> <p>Dictionary containing the fields to update and their new values</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The updated model instance or None if not found/updated or if the ID format is invalid</p> Note <p>Uses MongoDB's $set operator to update only the specified fields</p> Source code in <code>src/chalifour/db/repository/_mongo_db_model_repository.py</code> <pre><code>def update(self, model_id: Any, update_data: Dict[str, Any]) -&gt; Optional[T]:\n    \"\"\"\n    Update an existing document by its _id.\n\n    Args:\n        model_id: The document's _id (can be string or ObjectId)\n        update_data: Dictionary containing the fields to update and their new values\n\n    Returns:\n        The updated model instance or None if not found/updated or if the ID format is invalid\n\n    Note:\n        Uses MongoDB's $set operator to update only the specified fields\n    \"\"\"\n    if not isinstance(model_id, ObjectId):\n        try:\n            model_id = ObjectId(model_id)\n        except Exception:\n            return None\n\n    try:\n        result = self.collection.update_one(\n            {\"_id\": model_id}, {\"$set\": update_data}\n        )\n        if result.matched_count &gt; 0:\n            return self.get_by_id(model_id)  # Fetch the updated document\n        return None\n    except DuplicateKeyError as e:\n        print(f\"MongoDB update error: {e}\")\n        return None\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository","title":"<code>SQLAlchemyModelRepository</code>","text":"<p>               Bases: <code>ModelRepository[T]</code></p> <p>SQLAlchemy implementation of the ModelRepository interface.</p> <p>This class provides CRUD operations for SQLAlchemy models, handling session management and database interactions. It implements all abstract methods defined in the ModelRepository base class.</p> <p>Attributes:</p> Name Type Description <code>engine</code> <p>SQLAlchemy engine instance connected to the database</p> <code>model_class</code> <p>The SQLAlchemy model class this manager will operate on</p> <code>Session</code> <p>SQLAlchemy sessionmaker factory for creating new sessions</p> Source code in <code>src/chalifour/db/repository/_sql_alchemy_model_repository.py</code> <pre><code>class SQLAlchemyModelRepository(ModelRepository[T]):\n    \"\"\"\n    SQLAlchemy implementation of the ModelRepository interface.\n\n    This class provides CRUD operations for SQLAlchemy models, handling session\n    management and database interactions. It implements all abstract methods\n    defined in the ModelRepository base class.\n\n    Attributes:\n        engine: SQLAlchemy engine instance connected to the database\n        model_class: The SQLAlchemy model class this manager will operate on\n        Session: SQLAlchemy sessionmaker factory for creating new sessions\n    \"\"\"\n\n    def __init__(self, model_class: Type[T]):\n        \"\"\"\n        Initialize the SQLAlchemy model manager.\n\n        Args:\n            model_class: The SQLAlchemy model class this manager will operate on\n                         (must be a subclass of the declarative Base)\n\n        Note:\n            This constructor automatically creates the necessary tables in the database\n            if they don't already exist.\n        \"\"\"\n        super().__init__(model_class)\n\n        db_uri = os.environ.get(\"SQL_ALCHEMY_DB_URI\", \"sqlite:///database.sqlite3\")\n\n        self.engine = create_engine(db_uri)\n        Base.metadata.create_all(self.engine)  # Ensure table exists for this model\n        self.Session = sessionmaker(bind=self.engine)\n\n    def create(self, model_data: Dict[str, Any]) -&gt; Optional[T]:\n        \"\"\"\n        Creates a new model instance in the database.\n\n        Args:\n            model_data: Dictionary containing the data for the new model instance\n                        with keys corresponding to model attributes\n\n        Returns:\n            The created model instance with any auto-generated fields populated,\n            or None if creation fails (e.g., due to integrity constraints)\n\n        Note:\n            This method handles session management and automatically rolls back\n            the transaction in case of IntegrityError.\n        \"\"\"\n        session = self.Session()\n        try:\n            new_instance = self.model_class(**model_data)\n            session.add(new_instance)\n            session.commit()\n            session.refresh(new_instance)  # Refresh to get auto-generated ID if any\n            return new_instance\n        except IntegrityError as e:\n            session.rollback()\n            print(f\"SQLAlchemy create error: {e}\")\n            return None\n        finally:\n            session.close()\n\n    def get_by_id(self, model_id: Any) -&gt; Optional[T]:\n        \"\"\"\n        Retrieves a model instance by its primary key ID.\n\n        Args:\n            model_id: The primary key value of the model to retrieve\n\n        Returns:\n            The model instance if found, or None if no model exists with the given ID\n        \"\"\"\n        session = self.Session()\n        try:\n            return session.query(self.model_class).get(model_id)\n        finally:\n            session.close()\n\n    def find_one(self, query: Dict[str, Any]) -&gt; Optional[T]:\n        \"\"\"\n        Finds a single model instance based on a query dictionary.\n\n        Args:\n            query: Dictionary of attribute-value pairs to filter by (exact matches only)\n                  For example: {'name': 'John', 'active': True}\n\n        Returns:\n            The first matching model instance, or None if no match is found\n\n        Note:\n            This implementation uses SQLAlchemy's filter_by() for exact matches.\n            For more complex queries (e.g., with operators like &gt;, &lt;, LIKE),\n            a custom implementation would be needed.\n        \"\"\"\n        session = self.Session()\n        try:\n            # SQLAlchemy queries are built differently than NoSQL.\n            # We'll map dictionary query to filter_by or filter.\n            # For simplicity, we'll use filter_by for exact matches here.\n            # More complex queries might require using `filter` with `and_`, `or_` etc.\n            return session.query(self.model_class).filter_by(**query).first()\n        except Exception as e:\n            print(f\"SQLAlchemy find_one error: {e}\")\n            return None\n        finally:\n            session.close()\n\n    def find_all(\n        self,\n        query: Optional[Dict[str, Any]] = None,\n        limit: Optional[int] = None,\n        skip: Optional[int] = None,\n    ) -&gt; List[T]:\n        \"\"\"\n        Finds all model instances matching a query, with optional pagination.\n\n        Args:\n            query: Optional dictionary of attribute-value pairs to filter by.\n                  If None, retrieves all instances of the model.\n            limit: Maximum number of results to return (for pagination)\n            skip: Number of results to skip (for pagination)\n\n        Returns:\n            A list of matching model instances, or an empty list if no matches\n            or if an error occurs\n\n        Example:\n            # Get all active users, 10 per page, starting from the 2nd page\n            users = manager.find_all({'active': True}, limit=10, skip=10)\n        \"\"\"\n        session = self.Session()\n        try:\n            q = session.query(self.model_class)\n            if query:\n                q = q.filter_by(**query)  # Apply filters\n            if skip is not None:\n                q = q.offset(skip)\n            if limit is not None:\n                q = q.limit(limit)\n            return q.all()\n        except Exception as e:\n            print(f\"SQLAlchemy find_all error: {e}\")\n            return []\n        finally:\n            session.close()\n\n    def update(self, model_id: Any, update_data: Dict[str, Any]) -&gt; Optional[T]:\n        \"\"\"\n        Updates an existing model instance by ID.\n\n        Args:\n            model_id: The primary key of the model to update\n            update_data: Dictionary containing the fields to update and their new values\n\n        Returns:\n            The updated model instance if found and updated successfully,\n            or None if the model wasn't found or an error occurred\n\n        Note:\n            This method handles session management and automatically rolls back\n            the transaction in case of IntegrityError (e.g., unique constraint violations).\n        \"\"\"\n        session = self.Session()\n        try:\n            instance = session.query(self.model_class).get(model_id)\n            if instance:\n                for key, value in update_data.items():\n                    setattr(instance, key, value)\n                session.commit()\n                session.refresh(instance)\n                return instance\n            return None\n        except IntegrityError as e:\n            session.rollback()\n            print(f\"SQLAlchemy update error: {e}\")\n            return None\n        finally:\n            session.close()\n\n    def delete(self, model_id: Any) -&gt; bool:\n        \"\"\"\n        Deletes a model instance by its ID.\n\n        Args:\n            model_id: The primary key of the model to delete\n\n        Returns:\n            True if the model was found and deleted successfully,\n            False if the model wasn't found\n        \"\"\"\n        session = self.Session()\n        try:\n            instance = session.query(self.model_class).get(model_id)\n            if instance:\n                session.delete(instance)\n                session.commit()\n                return True\n            return False\n        finally:\n            session.close()\n\n    def count(self, query: Optional[Dict[str, Any]] = None) -&gt; int:\n        \"\"\"\n        Counts the number of model instances matching a query.\n\n        Args:\n            query: Optional dictionary of attribute-value pairs to filter by.\n                  If None, counts all instances of the model.\n\n        Returns:\n            The number of matching instances\n\n        Example:\n            # Count all active users\n            active_user_count = manager.count({'active': True})\n        \"\"\"\n        session = self.Session()\n        try:\n            q = session.query(self.model_class)\n            if query:\n                q = q.filter_by(**query)\n            return q.count()\n        finally:\n            session.close()\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository.__init__","title":"<code>__init__(model_class)</code>","text":"<p>Initialize the SQLAlchemy model manager.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>Type[T]</code> <p>The SQLAlchemy model class this manager will operate on          (must be a subclass of the declarative Base)</p> required Note <p>This constructor automatically creates the necessary tables in the database if they don't already exist.</p> Source code in <code>src/chalifour/db/repository/_sql_alchemy_model_repository.py</code> <pre><code>def __init__(self, model_class: Type[T]):\n    \"\"\"\n    Initialize the SQLAlchemy model manager.\n\n    Args:\n        model_class: The SQLAlchemy model class this manager will operate on\n                     (must be a subclass of the declarative Base)\n\n    Note:\n        This constructor automatically creates the necessary tables in the database\n        if they don't already exist.\n    \"\"\"\n    super().__init__(model_class)\n\n    db_uri = os.environ.get(\"SQL_ALCHEMY_DB_URI\", \"sqlite:///database.sqlite3\")\n\n    self.engine = create_engine(db_uri)\n    Base.metadata.create_all(self.engine)  # Ensure table exists for this model\n    self.Session = sessionmaker(bind=self.engine)\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository.count","title":"<code>count(query=None)</code>","text":"<p>Counts the number of model instances matching a query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of attribute-value pairs to filter by.   If None, counts all instances of the model.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of matching instances</p> Example Source code in <code>src/chalifour/db/repository/_sql_alchemy_model_repository.py</code> <pre><code>def count(self, query: Optional[Dict[str, Any]] = None) -&gt; int:\n    \"\"\"\n    Counts the number of model instances matching a query.\n\n    Args:\n        query: Optional dictionary of attribute-value pairs to filter by.\n              If None, counts all instances of the model.\n\n    Returns:\n        The number of matching instances\n\n    Example:\n        # Count all active users\n        active_user_count = manager.count({'active': True})\n    \"\"\"\n    session = self.Session()\n    try:\n        q = session.query(self.model_class)\n        if query:\n            q = q.filter_by(**query)\n        return q.count()\n    finally:\n        session.close()\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository.count--count-all-active-users","title":"Count all active users","text":"<p>active_user_count = manager.count({'active': True})</p>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository.create","title":"<code>create(model_data)</code>","text":"<p>Creates a new model instance in the database.</p> <p>Parameters:</p> Name Type Description Default <code>model_data</code> <code>Dict[str, Any]</code> <p>Dictionary containing the data for the new model instance         with keys corresponding to model attributes</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The created model instance with any auto-generated fields populated,</p> <code>Optional[T]</code> <p>or None if creation fails (e.g., due to integrity constraints)</p> Note <p>This method handles session management and automatically rolls back the transaction in case of IntegrityError.</p> Source code in <code>src/chalifour/db/repository/_sql_alchemy_model_repository.py</code> <pre><code>def create(self, model_data: Dict[str, Any]) -&gt; Optional[T]:\n    \"\"\"\n    Creates a new model instance in the database.\n\n    Args:\n        model_data: Dictionary containing the data for the new model instance\n                    with keys corresponding to model attributes\n\n    Returns:\n        The created model instance with any auto-generated fields populated,\n        or None if creation fails (e.g., due to integrity constraints)\n\n    Note:\n        This method handles session management and automatically rolls back\n        the transaction in case of IntegrityError.\n    \"\"\"\n    session = self.Session()\n    try:\n        new_instance = self.model_class(**model_data)\n        session.add(new_instance)\n        session.commit()\n        session.refresh(new_instance)  # Refresh to get auto-generated ID if any\n        return new_instance\n    except IntegrityError as e:\n        session.rollback()\n        print(f\"SQLAlchemy create error: {e}\")\n        return None\n    finally:\n        session.close()\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository.delete","title":"<code>delete(model_id)</code>","text":"<p>Deletes a model instance by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>Any</code> <p>The primary key of the model to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the model was found and deleted successfully,</p> <code>bool</code> <p>False if the model wasn't found</p> Source code in <code>src/chalifour/db/repository/_sql_alchemy_model_repository.py</code> <pre><code>def delete(self, model_id: Any) -&gt; bool:\n    \"\"\"\n    Deletes a model instance by its ID.\n\n    Args:\n        model_id: The primary key of the model to delete\n\n    Returns:\n        True if the model was found and deleted successfully,\n        False if the model wasn't found\n    \"\"\"\n    session = self.Session()\n    try:\n        instance = session.query(self.model_class).get(model_id)\n        if instance:\n            session.delete(instance)\n            session.commit()\n            return True\n        return False\n    finally:\n        session.close()\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository.find_all","title":"<code>find_all(query=None, limit=None, skip=None)</code>","text":"<p>Finds all model instances matching a query, with optional pagination.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Optional[Dict[str, Any]]</code> <p>Optional dictionary of attribute-value pairs to filter by.   If None, retrieves all instances of the model.</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of results to return (for pagination)</p> <code>None</code> <code>skip</code> <code>Optional[int]</code> <p>Number of results to skip (for pagination)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[T]</code> <p>A list of matching model instances, or an empty list if no matches</p> <code>List[T]</code> <p>or if an error occurs</p> Example Source code in <code>src/chalifour/db/repository/_sql_alchemy_model_repository.py</code> <pre><code>def find_all(\n    self,\n    query: Optional[Dict[str, Any]] = None,\n    limit: Optional[int] = None,\n    skip: Optional[int] = None,\n) -&gt; List[T]:\n    \"\"\"\n    Finds all model instances matching a query, with optional pagination.\n\n    Args:\n        query: Optional dictionary of attribute-value pairs to filter by.\n              If None, retrieves all instances of the model.\n        limit: Maximum number of results to return (for pagination)\n        skip: Number of results to skip (for pagination)\n\n    Returns:\n        A list of matching model instances, or an empty list if no matches\n        or if an error occurs\n\n    Example:\n        # Get all active users, 10 per page, starting from the 2nd page\n        users = manager.find_all({'active': True}, limit=10, skip=10)\n    \"\"\"\n    session = self.Session()\n    try:\n        q = session.query(self.model_class)\n        if query:\n            q = q.filter_by(**query)  # Apply filters\n        if skip is not None:\n            q = q.offset(skip)\n        if limit is not None:\n            q = q.limit(limit)\n        return q.all()\n    except Exception as e:\n        print(f\"SQLAlchemy find_all error: {e}\")\n        return []\n    finally:\n        session.close()\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository.find_all--get-all-active-users-10-per-page-starting-from-the-2nd-page","title":"Get all active users, 10 per page, starting from the 2nd page","text":"<p>users = manager.find_all({'active': True}, limit=10, skip=10)</p>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository.find_one","title":"<code>find_one(query)</code>","text":"<p>Finds a single model instance based on a query dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Dict[str, Any]</code> <p>Dictionary of attribute-value pairs to filter by (exact matches only)   For example: {'name': 'John', 'active': True}</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The first matching model instance, or None if no match is found</p> Note <p>This implementation uses SQLAlchemy's filter_by() for exact matches. For more complex queries (e.g., with operators like &gt;, &lt;, LIKE), a custom implementation would be needed.</p> Source code in <code>src/chalifour/db/repository/_sql_alchemy_model_repository.py</code> <pre><code>def find_one(self, query: Dict[str, Any]) -&gt; Optional[T]:\n    \"\"\"\n    Finds a single model instance based on a query dictionary.\n\n    Args:\n        query: Dictionary of attribute-value pairs to filter by (exact matches only)\n              For example: {'name': 'John', 'active': True}\n\n    Returns:\n        The first matching model instance, or None if no match is found\n\n    Note:\n        This implementation uses SQLAlchemy's filter_by() for exact matches.\n        For more complex queries (e.g., with operators like &gt;, &lt;, LIKE),\n        a custom implementation would be needed.\n    \"\"\"\n    session = self.Session()\n    try:\n        # SQLAlchemy queries are built differently than NoSQL.\n        # We'll map dictionary query to filter_by or filter.\n        # For simplicity, we'll use filter_by for exact matches here.\n        # More complex queries might require using `filter` with `and_`, `or_` etc.\n        return session.query(self.model_class).filter_by(**query).first()\n    except Exception as e:\n        print(f\"SQLAlchemy find_one error: {e}\")\n        return None\n    finally:\n        session.close()\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository.get_by_id","title":"<code>get_by_id(model_id)</code>","text":"<p>Retrieves a model instance by its primary key ID.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>Any</code> <p>The primary key value of the model to retrieve</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The model instance if found, or None if no model exists with the given ID</p> Source code in <code>src/chalifour/db/repository/_sql_alchemy_model_repository.py</code> <pre><code>def get_by_id(self, model_id: Any) -&gt; Optional[T]:\n    \"\"\"\n    Retrieves a model instance by its primary key ID.\n\n    Args:\n        model_id: The primary key value of the model to retrieve\n\n    Returns:\n        The model instance if found, or None if no model exists with the given ID\n    \"\"\"\n    session = self.Session()\n    try:\n        return session.query(self.model_class).get(model_id)\n    finally:\n        session.close()\n</code></pre>"},{"location":"reference/chalifour/db/repository/#chalifour.db.repository.SQLAlchemyModelRepository.update","title":"<code>update(model_id, update_data)</code>","text":"<p>Updates an existing model instance by ID.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>Any</code> <p>The primary key of the model to update</p> required <code>update_data</code> <code>Dict[str, Any]</code> <p>Dictionary containing the fields to update and their new values</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The updated model instance if found and updated successfully,</p> <code>Optional[T]</code> <p>or None if the model wasn't found or an error occurred</p> Note <p>This method handles session management and automatically rolls back the transaction in case of IntegrityError (e.g., unique constraint violations).</p> Source code in <code>src/chalifour/db/repository/_sql_alchemy_model_repository.py</code> <pre><code>def update(self, model_id: Any, update_data: Dict[str, Any]) -&gt; Optional[T]:\n    \"\"\"\n    Updates an existing model instance by ID.\n\n    Args:\n        model_id: The primary key of the model to update\n        update_data: Dictionary containing the fields to update and their new values\n\n    Returns:\n        The updated model instance if found and updated successfully,\n        or None if the model wasn't found or an error occurred\n\n    Note:\n        This method handles session management and automatically rolls back\n        the transaction in case of IntegrityError (e.g., unique constraint violations).\n    \"\"\"\n    session = self.Session()\n    try:\n        instance = session.query(self.model_class).get(model_id)\n        if instance:\n            for key, value in update_data.items():\n                setattr(instance, key, value)\n            session.commit()\n            session.refresh(instance)\n            return instance\n        return None\n    except IntegrityError as e:\n        session.rollback()\n        print(f\"SQLAlchemy update error: {e}\")\n        return None\n    finally:\n        session.close()\n</code></pre>"}]}